#
# The maximum number of iterations to perform in planning.
# This may have different semantic depending of which planning algorithm is used.
# Type: Integer
# Default: Integer.MAX_VALUE
max_iterations = 2147483647
#
# Interval (in number of iterations) between which detailed executions informations are logged.
# Type: Integer
# Default: 10
log_intervals = 1
#
# Interval (in number of iterations) between which succint executions informations are logged.
# Type: Integer
# Default: 1
short_log_intervals = 1
#
# Type of planning algorithm to use.
# Type: PlannerTypes
# (Optional)
# Possible value:
#	- LINEAR_GENERIC: Generic (exhaustive) linear planning algorithm
#	- LINEAR_OPTIMIZED: Optimized linear planning algorithm. 
#	- LINEAR_KCHASE: Linear planning algorithm relying on KTERMINATION_CHASE reasoning type. 
#	- DAG_GENERIC: Generic (exhaustive) DAG planning algorithm
#	- DAG_SIMPLEDP: DAG planning algorithm, simulating classic DP plan optimization
#	- DAG_CHASEFRIENDLYDP: DAG DP planning algorithm, avoiding redundant chasing
#	- DAG_OPTIMIZED: DAG DP planning algorithm, relying on parallelism
#	- DAG_ILP: DAG planning algorithm using linear planning iteratively (Iterative Linear Planning)
#	- DAG_ILP_SI: DAG planning algorithm, a variant of ILP
#	- DAG_MIXED_ILP: DAG planning algorithm, a variant of ILP
planner_type = DAG_GENERIC
#
# Number of exploration interval to wait for between query match checks.
#  Use in linear planning algorithms only.
# Type: Integer
# (Optional)
query_match_interval = 1
#
# Type of reasoning to use.
# Type: ReasoningTypes
# Default: RESTRICTED_CHASE
# Possible value:
#	- BLOCKING_CHASE: Chase algorithm with blocking. To be use in cases where the chase does not terminate.
#	- RESTRICTED_CHASE: Restricted chase as defined in the literature
#	- KTERMINATION_CHASE: Restricted chase, where the number of rule firing rounds is bounded by a constant K
reasoning_type = RESTRICTED_CHASE
#
# Type of the homomorphism detected infrastructure
# Type: HomomorphismDetectorTypes
# (Optional)
# Possible value:
#	- DATABASE: Homomorphism checker relying on an internal relational database
homomorphism_detector_type = DATABASE
#
# Number of intervals between which to run the chase
# Type: Integer
# (Optional)
chase_interval = 5
#
# Maximum depth of the exploration.
# This may have different semantic depending of which planning algorithm is used.
# Type: Integer
# (Optional)
max_depth = 2147483647
#
# Maximum level of bushiness allowed.
#  This is only used with ILP-types of planning algorithms
# Type: Integer
# Default: Integer.MAX_VALUE
max_bushiness = 2147483647
#
# Range configurations to consider as inputs to each subsequent phase of a DAG planning algorithm.
# Use in conjunction to DISTANCE2CORETOPK priority assessor
# Type: Integer
# Default: Integer.MAX_VALUE
range = 2147483647
#
# If true, a LimitReachedException is thrown during planning if a limit (e.g. time or max no. interactions) is reached.
# Otherwise, the event is logged and the planning completes gracefully
# Type: Boolean
# (Optional)
exception_on_limit = false
#
# Type of validator to use. Only required in conjunction with DAG planning algorithms
# Type: ValidatorTypes
# Default: DEFAULT
# Possible value:
#	- DEFAULT_VALIDATOR: No shape or type restriction
#	- APPLYRULE_VALIDATOR: Requires at least one of the input configurations to be an ApplyRule
#	- DEPTH_VALIDATOR: Restricts the depth of the plans visited 
#	- RIGHT_DEPTH_VALIDATOR: Restricts the depth of the RHS plans used
#	- APPLYRULE_DEPTH_VALIDATOR: Combination of APPLYRULE_VALIDATOR and DEPTH_VALIDATOR
#	- LINEAR_VALIDATOR: Restricts the shape of plans to left-deep ones
#	- STRICT_INCLUSION: Miscellaneous
validator_type = DEFAULT_VALIDATOR
#
# Type of priority assessor to use. Only required in conjunction with DAG planning algorithms
# Type: PriorityAssessorTypes
# Default: DEFAULT
# Possible value:
#	- DEFAULT: Default (no-op) priority assessor
#	- DISTANCE2CORETOPK: Assessor given priority to the K configurations that are closest to the core
#	- DISTANCE2CORERANGE: Assessor given priority to some range of configurations that are closest to the core
priority_assessor_type = DEFAULT
#
# Type of dominance checks to use. Only required in conjunction with DAG planning algorithms
# Type: DominanceTypes
# Default: STRICT_OPEN
# Possible value:
#	- CLOSED: Closed dominance. Given two closed configurations, one dominate the other if its facts are contained in the facts of the other, up to homomorphism
#	- OPEN: Open dominance. Given two possible open configurations, one dominate the other if 
dominance_type = OPEN
#
# Type of sucess dominance checks to use. Only required in conjunction with DAG planning algorithms
# Type: SuccessDominanceTypes
# Default: OPEN
# Possible value:
#	- CLOSED: Closed dominance on successful configurations.
#	- OPEN: Open dominance on successful configurations.
success_dominance_type = OPEN
#
# Specifies how follow-up joins should be handled.
# Only applies to DAG planning algorithms
# Type: FollowUpHandling
# Default: MINIMAL
# Possible value:
#	- MINIMAL: Minimal follow-up join.
#	  Upon initializing of a DAG plan search every follow-up join gives rise to an independant ApplyRule
#	- MAXIMAL: Maximal follow-up join.
#	  Upon initializing of a DAG plan search all follow-up joins gives rise to a single/common ApplyRule
follow_up_handling = MINIMAL
#
# Type of iterative executor to use. Only applies to DAG planning algorithms.
# Type: IterativeExecutorTypes
# Default: MULTITHREADED
# Possible value:
#	- MULTITHREADED: Multi-threaded executor for runningDAG planning rounds in parallel
iterative_executor_type = MULTITHREADED
#
# Number of threads to use in the first phase of a parallel DAG planning algorithm
# Type: Integer
# Default: 50
first_phase_threads = 50
#
# Number of threads to use in the second phase of a parallel DAG planning algorithm
# Type: Integer
# Default: 50
second_phase_threads = 50
#
# Threshold for the DEPTH_THROTTLING validator
# Type: Integer
# Default: 2
depth_threshold = 2
#
# Top-K configurations to consider as inputs to each subsequent phase of a DAG planning algorithm.
# Use in conjunction to ILP SI planning algorithm
# Type: Integer
# Default: 4
topk = 4
#
# Top configurations to consider as inputs to each subsequent phase of a DAG planning algorithm.
# Use in conjunction to DISTANCE2CORETOPK priority assessor
# Type: Integer
# Default: Integer.MAX_VALUE
top_configurations = 2147483647
#
# Number of rounds of rule firings to perform, in a single application of the chase. 
# Only applies to KTERMINATION_CHASE reasoning type.
# Type: Integer
# Default: Integer.MAX_VALUE
termination_k = 2147483647
#
# In true, the initial configuration is full initialized at the beginning of a planning algorithm.
# Only applies to DAG planning algorithms
# Type: Boolean
# Default: false
full_initialization = false
#
# If true, relation that are not reachable from the input query through the firing of constraints are not considered in the plan search.
#  Only applies to DAG planning algorithms
# Type: Boolean
# Default: false
reachability_filtering = false
#
# If true, all join orders are considered during plan search
# Type: Boolean
# Default: true
order_aware = true
#
# If true, then we perform (de)zombification during optimised linear plan exploration plan search
# Type: Boolean
# Default: true
zombification = false
#
# Randomizer seed shared by all randomizer across the PDQ libraries.
# Type: Integer
# Default: 0
seed = 1
#
# Time limit (in ms).
# Type: Double
# Default: Infinity
timeout = 3600000.0
#
# Type of query translator to use in the BLACKBOX_DBcost estimator (required if the cost_type=BLACKBOX_DB)
# Type: BlackBoxQueryTypes
# (Optional)
# Possible value:
#	- DEFAULT: Default translator from DAG plan to SQL for blackbox cost estimation
#	- SQL_WITH: Translator from DAG plan to SQL WITH query for blackbox cost estimation
black_box_query_type = DEFAULT
#
# Type of cost estimation to use. This has an influence on the requirements of other planner parameters.
# If such requirements are violated, a PlannerException will be thrown upon initialization of the Planner.
# Type: CostTypes
# Default: TEXTBOOK
# Possible value:
#	- FIXED_COST_PER_ACCESS: Estimates the cost as the sum of the cost of all accesses in a plan, 
#	   where access cost are provided externally
#	- COUNT_NUMBER_OF_ACCESSED_RELATIONS: Estimates the cost as the sum of the cost of all accesses in a plan, 
#	   where cost are assigned randomly
#	- FIXED_COST_PER_ACCESS: Estimates the cost as the sum of the cost of all accesses in a plan, 
#	   where cost are measured automatically from the underlying datasources
#	- COUNT_NUMBER_OF_ACCESSED_RELATIONS: Estimates the cost as the sum of all accesses in a plan
#	- TEXTBOOK: Estimates the cost through some externally defined cost function.
#	  Currently, this defaults to the white box cost functions relying on textbox cost estimation techniques
#	- BLACKBOX_DB: Estimates the cost by translating the query to SQL and asking its cost to a database
#	- INVERSE_LENGTH: Experimental: estimates the cost as the number of atoms in a plan
#	- SIMPLE_ERSPI: Estimates the cost as the sum of the estimated result size per invocation associated to each access method used in a plan
cost_type = COUNT_NUMBER_OF_ACCESSED_RELATIONS
#
# Type of cardinality estimation to use.
# Type: CardinalityEstimationTypes
# Default: NAIVE
# Possible value:
#	- NAIVE: Naive cardinality estimation, based on external defined constant join/selectivity reduction factors
cardinality_estimation_type = NAIVE
#
# Randomizer seed shared by all randomizer across the PDQ libraries.
# Type: Integer
# Default: 0
seed = 1
#
# Time limit (in ms).
# Type: Double
# Default: Infinity
timeout = 3600000.0
