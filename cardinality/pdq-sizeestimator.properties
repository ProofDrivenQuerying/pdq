#
# Randomizer seed shared by all randomizer across the PDQ libraries.
# Type: Integer
# Default: 0
seed = 1
#
# Time limit (in ms).
# Type: Double
# Default: Infinity
timeout = 60000.0
#
# Canonical name of the driver class for the internal database used by the reasoner
# Type: String
# (Optional)
database_driver = org.apache.derby.jdbc.EmbeddedDriver
#
# Connection URL for the internal database used by the reasoner
# Type: String
# (Optional)
connection_url = jdbc:derby:memory:{1};create=true
#
# Name of the internal database used by the reasoner
# Type: String
# (Optional)
database_name = chase_regression
#
# Username for the internal database used by the reasoner
# Type: String
# (Optional)
database_user = root
#
# Password for the internal database used by the reasoner
# Type: String
# (Optional)
database_password = root
#
# Connection URL for the database used by the BLACKBOX_DB cost estimator (required if the cost_type=BLACKBOX_DB)
# Type: String
# (Optional)
black_box_connection_url = null
#
# Name of the database used by the BLACKBOX_DB cost estimator (required if the cost_type=BLACKBOX_DB)
# Type: String
# (Optional)
black_box_database_name = null
#
# Username for the database used by the BLACKBOX_DB cost estimator (required if the cost_type=BLACKBOX_DB)
# Type: String
# (Optional)
black_box_database_user = null
#
# Password for the database used by the BLACKBOX_DB cost estimator (required if the cost_type=BLACKBOX_DB)
# Type: String
# (Optional)
black_box_database_password = null
#
# Type of query translator to use in the BLACKBOX_DBcost estimator (required if the cost_type=BLACKBOX_DB)
# Type: BlackBoxQueryTypes
# (Optional)
# Possible value:
#	- DEFAULT: Default translator from DAG plan to SQL for blackbox cost estimation
#	- SQL_WITH: Translator from DAG plan to SQL WITH query for blackbox cost estimation
black_box_query_type = DEFAULT
#
# The maximum number of iterations to perform in planning.
# This may have different semantic depending of which planning algorithm is used.
# Type: Integer
# Default: Integer.MAX_VALUE
max_iterations = 2147483647
#
# Interval (in number of iterations) between which detailed executions informations are logged.
# Type: Integer
# Default: 10
log_intervals = 500
#
# Interval (in number of iterations) between which succint executions informations are logged.
# Type: Integer
# Default: 1
short_log_intervals = 100
#
# Path of the output file where to store the logs (optional). If missing, logs are printed to STDOUT
# Type: String
# (Optional)
output_log_path = null
#
# Type of cost estimation to use. This has an influence on the requirements of other planner parameters.
# If such requirements are violated, a PlannerException will be thrown upon initialization of the Planner.
# Type: CostTypes
# (Optional)
# Possible value:
#	- SIMPLE_CONSTANT: Estimates the cost are the sum of the cost of all accesses in a plan, 
#	   where cost are provided externally
#	- SIMPLE_RANDOM: Estimates the cost are the sum of the cost of all accesses in a plan, 
#	   where cost are assigned randomly
#	- SIMPLE_GIVEN: Estimates the cost are the sum of the cost of all accesses in a plan, 
#	   where cost are measured automatically from the underlying datasources
#	- SIMPLE_COUNT: Estimates the cost are the sum of all accesses in a plan
#	- BLACKBOX: Estimates the cost through some externally defined cost function.
#	  Currently, this defaults to the white box cost functions relying on textbox cost estimation techniques
#	- BLACKBOX_DB: Estimates the cost by translating the query to SQL and asking its cost to a database
#	- INVERSE_LENGTH: Experimental: estimates the cost as the number of atoms in a plan
#	- SIMPLE_DB: Experimental: 
cost_type = BLACKBOX
#
# Type of cardinality estimation to use.
# Type: CardinalityEstimationTypes
# Default: NAIVE
# Possible value:
#	- NAIVE: Naive cardinality estimation, based on external defined constant join/selectivity reduction factors
cardinality_estimation_type = NAIVE
#
# Type of planning algorithm to use.
# Type: PlannerTypes
# (Optional)
# Possible value:
#	- LINEAR_GENERIC: Generic (exhaustive) linear planning algorithm
#	- LINEAR_OPTIMIZED: Optimized linear planning algorithm. 
#	- LINEAR_KCHASE: Linear planning algorithm relying on KTERMINATION_CHASE reasoning type. 
#	- DAG_GENERIC: Generic (exhaustive) DAG planning algorithm
#	- DAG_SIMPLEDP: DAG planning algorithm, simulating classic DP plan optimization
#	- DAG_CHASEFRIENDLYDP: DAG DP planning algorithm, avoiding redundant chasing
#	- DAG_OPTIMIZED: DAG DP planning algorithm, relying on parallelism
#	- DAG_ILP: DAG planning algorithm using linear planning iteratively (Iterative Linear Planning)
#	- DAG_ILP_SI: DAG planning algorithm, a variant of ILP
#	- DAG_MIXED_ILP: DAG planning algorithm, a variant of ILP
planner_type = LINEAR_OPTIMIZED
#
# Number of exploration interval to wait for between query match checks.
#  Use in linear planning algorithms only.
# Type: Integer
# (Optional)
query_match_interval = 1
#
# Number of exploration interval to wait for between blocking checks.
# Type: Integer
# (Optional)
blocking_interval = null
#
# Type of reasoning to use.
# Type: ReasoningTypes
# (Optional)
# Possible value:
#	- BLOCKING_CHASE: Chase algorithm with blocking. To be use in cases where the chase does not terminate.
#	- RESTRICTED_CHASE: Restricted chase as defined in the literature
#	- KTERMINATION_CHASE: Restricted chase, where the number of rule firing rounds is bounded by a constant K
#	- BOUNDED_CHASE: Restricted chase, where the number of rule firing rounds is bounded by a constant, which is automatically detected from the rules.
reasoning_type = RESTRICTED_CHASE
#
# Type of the homomorphism detected infrastructure
# Type: HomomorphismDetectorTypes
# (Optional)
# Possible value:
#	- DATABASE: Homomorphism checker relying on an internal relational database
homomorphism_detector_type = DATABASE
#
# Type of post-pruning. This is only used in optimizer linear planning
# Type: PostPruningTypes
# Default: NONE
# Possible value:
#	- NONE: No post-pruning
#	- SIMPLE: Basic post-pruning
#	- IMPROVED: A more involved version of SIMPLE post-pruning
post_pruning_types = NONE
#
# Number of intervals between which to run the chase
# Type: Integer
# (Optional)
chase_interval = null
#
# Maximum depth of the exploration.
# This may have different semantic depending of which planning algorithm is used.
# Type: Integer
# (Optional)
max_depth = 2147483647
#
# Maximum level of bushiness allowed.
#  This is only used with ILP-types of planning algorithms
# Type: Integer
# Default: Integer.MAX_VALUE
max_bushiness = 2147483647
#
# Range configurations to consider as inputs to each subsequent phase of a DAG planning algorithm.
# Use in conjunction to DISTANCE2CORETOPK priority assessor
# Type: Integer
# Default: Integer.MAX_VALUE
range = 2147483647
#
# If true, a LimitReachedException is thrown during planning if a limit (e.g. time or max no. interactions) is reached.
# Otherwise, the event is logged and the planning completes gracefully
# Type: Boolean
# (Optional)
exception_on_limit = false
#
# Type of validator to use. Only required in conjunction with DAG planning algorithms
# Type: ValidatorTypes
# Default: DEFAULT
# Possible value:
#	- DEFAULT: Default (no-op) validator
#	- FACT_THROTTLING: Rules out all configurations but those not not contained in any other one
#	- DEPTH_THROTTLING: Rules out configurations beyond a given depth
#	- RIGHT_DEPTH_THROTTLING: Rules out configurations beyond a given RHS depth
#	- FACT_DEPTH_THROTTLING: Combination of fact and depth throttling
#	- LINEAR: Rules out non-linear configurations
#	- NUMERICAL_THROTTLING: Rules out all but configurations with the highest number of facts
#	- STRICT_INCLUSION: Rules out all but configurations not strictly including in another one
validator_type = DEFAULT
#
# Type of priority assessor to use. Only required in conjunction with DAG planning algorithms
# Type: PriorityAssessorTypes
# Default: DEFAULT
# Possible value:
#	- DEFAULT: Default (no-op) priority assessor
#	- DISTANCE2CORETOPK: Assessor given priority to the K configurations that are closest to the core
#	- DISTANCE2CORERANGE: Assessor given priority to some range of configurations that are closest to the core
priority_assessor_type = DEFAULT
#
# Type of filter to use. Only required in conjunction with DAG planning algorithms
# Type: FilterTypes
# (Optional)
filter_type = null
#
# Type of dominance checks to use. Only required in conjunction with DAG planning algorithms
# Type: DominanceTypes
# Default: STRICT_OPEN
# Possible value:
#	- CLOSED: Closed dominance. Given two closed configurations, one dominate the other if its facts are contained in the facts of the other, up to homomorphism
#	- STRICT_OPEN: Open dominance. Given two possible open configurations, one dominate the other if 
dominance_type = OPEN
#
# Type of sucess dominance checks to use. Only required in conjunction with DAG planning algorithms
# Type: SuccessDominanceTypes
# Default: OPEN
# Possible value:
#	- CLOSED: Closed dominance on successful configurations.
#	- OPEN: Open dominance on successful configurations.
success_dominance_type = OPEN
#
# Type of sucess dominance checks to use.
#  Only applies to DAG planning algorithms
# Type: ControlFlows
# Default: TOP_DOWN
# Possible value:
#	- BOTTOM_UP: Pull control flow allowing tuples to move bottom-up only
#	- TOP_DOWN: Pull control flow allowing tuples to move top-down and bottom-up
#	- PUSH: Control flow where children inform their parent when tuple are available
control_flow = TOP_DOWN
#
# Specifies how follow-up joins should be handled.
# Only applies to DAG planning algorithms
# Type: FollowUpHandling
# Default: MAXIMAL
# Possible value:
#	- MINIMAL: Minimal follow-up join.
#	  Upon initializing of a DAG plan search every follow-up join gives rise to an independant ApplyRule
#	- MAXIMAL: Maximal follow-up join.
#	  Upon initializing of a DAG plan search all follow-up joins gives rise to a single/common ApplyRule
follow_up_handling = MINIMAL
#
# Type of iterative executor to use. Only applies to DAG planning algorithms.
# Type: IterativeExecutorTypes
# Default: MULTITHREADED
# Possible value:
#	- MULTITHREADED: Multi-threaded executor for runningDAG planning rounds in parallel
iterative_executor_type = MULTITHREADED
#
# Number of threads to use in the first phase of a parallel DAG planning algorithm
# Type: Integer
# Default: 50
first_phase_threads = 50
#
# Number of threads to use in the second phase of a parallel DAG planning algorithm
# Type: Integer
# Default: 50
second_phase_threads = 50
#
# Threshold for the DEPTH_THROTTLING validator
# Type: Integer
# Default: 2
depth_threshold = 2
#
# Top-K configurations to consider as inputs to each subsequent phase of a DAG planning algorithm.
# Use in conjunction to ILP SI planning algorithm
# Type: Integer
# Default: 4
topk = 4
#
# Top configurations to consider as inputs to each subsequent phase of a DAG planning algorithm.
# Use in conjunction to DISTANCE2CORETOPK priority assessor
# Type: Integer
# Default: Integer.MAX_VALUE
top_configurations = 2147483647
#
# Number of rounds of rule firings to perform, in a single application of the chase. 
# Only applies to KTERMINATION_CHASE reasoning type.
# Type: Integer
# Default: Integer.MAX_VALUE
termination_k = 2147483647
#
# In true, the initial configuration is full initialized at the beginning of a planning algorithm.
# Only applies to DAG planning algorithms
# Type: Boolean
# Default: false
full_initialization = false
#
# If true, relation that are not reachable from the input query through the firing of constraints are not considered in the plan search.
#  Only applies to DAG planning algorithms
# Type: Boolean
# Default: false
reachability_filtering = false
#
# If true, all join orders are considered during plan search
# Type: Boolean
# Default: true
order_aware = true
